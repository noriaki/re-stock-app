# UI開発ガイドライン

## 基本方針

ReStockアプリケーションのUI開発においては、以下の基本方針に従います：

- Next.jsのAppルーターを基本フレームワークとして使用
- TypeScriptによる型安全な実装
- Tailwind CSSとshadcn/uiを活用したデザインシステム
- レスポンシブデザインとアクセシビリティの確保

## コンポーネント設計

### 基本構造

1. **ファイル命名規則**:
   - コンポーネントファイル: kebab-case（例: `user-profile.tsx`）
   - コンポーネント名: PascalCase（例: `UserProfile`）
   - ユーティリティ関数: camelCase（例: `formatDate`）

2. **コンポーネント分類**:
   - ページコンポーネント（app/ディレクトリ内）
   - 再利用可能なUIコンポーネント（components/ui/）
   - 機能コンポーネント（components/features/）
   - レイアウトコンポーネント（components/layouts/）

3. **型定義**:
   - Props型は明示的に定義（types/ディレクトリまたはコンポーネントファイル内）
   - 可能な限りブランド型を活用
   - import typeを使用して型のみをインポート

### スタイリングガイド

1. **Tailwind CSS**:
   - ユーティリティクラスを基本とする
   - 変数ベースの色（`bg-primary`, `text-primary-foreground`など）を使用
   - 命名クラスよりもユーティリティクラスを優先
   - カスタムクラスは必要最小限にとどめる

2. **shadcn/ui**:
   - 基本的なUIコンポーネントは可能な限りshadcn/uiを利用
   - 必要に応じてカスタマイズする場合も、Tailwindの原則を維持
   - カラースキームの一貫性を保つ

3. **レスポンシブ対応**:
   - モバイルファーストアプローチ
   - Tailwindの修飾子（sm:, md:, lg:, xl:）を活用
   - flexboxとgridレイアウトを適切に使用
   - メディアクエリは極力避け、Tailwindの修飾子で対応

## アクセシビリティ対応

1. **セマンティックHTML**:
   - 適切なHTML要素を使用（article, section, main, nav, header, footerなど）
   - 見出しの階層（h1～h6）を適切に維持
   - landmarkロールを活用

2. **ARIA属性**:
   - 必要に応じてaria-*属性を設定
   - aria-labelやaria-describedbyでコンテキストを提供
   - WAI-ARIAのベストプラクティスに従う

3. **フォーカス管理**:
   - キーボードナビゲーションをサポート
   - フォーカスインジケータを視覚的に明確に
   - focus-visibleユーティリティの活用

4. **スクリーンリーダー対応**:
   - sr-onlyクラスを使用して視覚的に隠された説明テキストを提供
   - 画像には適切なalt属性を設定
   - アイコンやシンボルに意味がある場合は適切なテキスト代替を提供

## データ表示とフォーム

1. **データ表示**:
   - データ表示は明確で読みやすく
   - 適切なフォーマットとグループ化
   - スケルトンローダーを用いた読み込み状態の表示
   - エラー状態の適切な処理と表示

2. **フォーム実装**:
   - バリデーションと適切なエラーメッセージ
   - アクセシブルなラベル付け
   - 入力ヘルパーテキストの提供
   - フォームの状態（送信中、成功、エラー）を視覚的に表示

3. **検索とフィルタリング**:
   - 直感的なUI
   - インクリメンタル検索の実装
   - フィルター条件の視覚的な表示
   - クリアと初期状態へのリセット機能

## 状態管理

1. **ローカル状態**:
   - React Hooksを活用（useState, useReducer）
   - 状態の範囲を最小限に保つ
   - 関連する状態はuseReducerでまとめる

2. **グローバル状態**:
   - Context APIを活用
   - 状態の更新ロジックを明確に分離
   - 適切なメモ化でパフォーマンスを最適化

3. **サーバー状態**:
   - サーバーコンポーネントを活用したデータフェッチング
   - クライアントコンポーネントではSWRまたはReact Queryを検討
   - エラー状態とローディング状態の適切な処理

## パフォーマンス最適化

1. **レンダリング最適化**:
   - 不要な再レンダリングを避ける（memo, useCallback, useMemo）
   - 大きなリストには仮想化を検討
   - Code SplittingとLazy Loadingを活用

2. **画像最適化**:
   - Next.js Imageコンポーネントを使用
   - 適切なサイズとフォーマットを指定
   - loading="lazy"属性の活用

3. **バンドルサイズ最適化**:
   - トリーシェイキングが効くように注意
   - 重いライブラリは必要な部分だけをインポート
   - 非同期インポートと遅延読み込みを検討

## ベストプラクティス

1. **コンポーネント設計**:
   - 単一責任の原則に従う
   - Props drilling を避ける（Context APIなどを活用）
   - コンポーネントは小さく、再利用可能に

2. **テスト**:
   - React Testing Libraryを使用したコンポーネントテスト
   - アクセシビリティのテスト
   - ユーザーインタラクションのテスト
   - スナップショットテスト

3. **ドキュメンテーション**:
   - コンポーネントの使用例を提供
   - PropsとAPIの明確な説明
   - Storybook等でのビジュアルドキュメント作成（必要に応じて）
