# Re-Stock アプリの UI 開発ガイドライン

## 基本方針

Re-Stock アプリの UI 開発においては、以下の基本方針に従います：

- Next.js の App ルーターを基本フレームワークとして使用
- TypeScript による型安全な実装
- Tailwind CSS と shadcn/ui を活用したデザインシステム
- レスポンシブデザインとアクセシビリティの確保

## コンポーネント設計

### 基本構造

1. **ファイル命名規則**:

   - コンポーネントファイル: kebab-case（例: `user-profile.tsx`）
   - コンポーネント名: PascalCase（例: `UserProfile`）
   - ユーティリティ関数: camelCase（例: `formatDate`）

2. **コンポーネント分類**:

   - ページコンポーネント（app/ディレクトリ内）
   - 再利用可能な UI コンポーネント（components/ui/）
   - 機能コンポーネント（components/features/）
   - レイアウトコンポーネント（components/layouts/）

3. **型定義**:
   - Props 型は明示的に定義（types/ディレクトリまたはコンポーネントファイル内）
   - 可能な限りブランド型を活用
   - import type を使用して型のみをインポート

### UI コンポーネント (components/ui/)

- shadcn/ui をベースとした再利用可能なコンポーネント
- プレゼンテーショナルコンポーネントとして実装
- ドメイン知識を含まない
- Props を通じてデータと振る舞いを受け取る

### 機能コンポーネント (components/features/)

- 特定の機能やユースケースに関連するコンポーネント
- UI コンポーネントを組み合わせて構成
- 状態管理と連携
- ドメインロジックは直接含まず、アプリケーションレイヤーを通じて利用

### コンポーネント構造

- 関数コンポーネントを使用する
- 小さく、単一責任の原則に従ったコンポーネントを作成する
- 複雑なロジックはカスタムフックに抽出する
- メモ化（React.memo, useMemo, useCallback）を適切に使用する

## スタイリングガイド

### Tailwind CSS

- ユーティリティクラスを基本とする
- 変数ベースの色（`bg-primary`, `text-primary-foreground`など）を使用
- 命名クラスよりもユーティリティクラスを優先
- カスタムクラスは必要最小限にとどめる

### shadcn/ui

- 基本的な UI コンポーネントは可能な限り shadcn/ui を利用
- 必要に応じてカスタマイズする場合も、Tailwind の原則を維持
- カラースキームの一貫性を保つ

## アクセシビリティ対応

### セマンティック HTML

- 適切な HTML 要素を使用（article, section, main, nav, header, footer など）
- 見出しの階層（h1 ～ h6）を適切に維持
- landmark ロールを活用

### ARIA 属性

- 必要に応じて aria-\*属性を設定
- aria-label や aria-describedby でコンテキストを提供
- WAI-ARIA のベストプラクティスに従う

### フォーカス管理

- キーボードナビゲーションをサポート
- フォーカスインジケータを視覚的に明確に
- focus-visible ユーティリティの活用

### スクリーンリーダー対応

- sr-only クラスを使用して視覚的に隠された説明テキストを提供
- 画像には適切な alt 属性を設定
- アイコンやシンボルに意味がある場合は適切なテキスト代替を提供

## データ表示とフォーム

### データ表示

- データ表示は明確で読みやすく
- 適切なフォーマットとグループ化
- スケルトンローダーを用いた読み込み状態の表示
- エラー状態の適切な処理と表示

### フォーム実装

- バリデーションと適切なエラーメッセージ
- アクセシブルなラベル付け
- 入力ヘルパーテキストの提供
- フォームの状態（送信中、成功、エラー）を視覚的に表示

### 検索とフィルタリング

- 直感的な UI
- インクリメンタル検索の実装
- フィルター条件の視覚的な表示
- クリアと初期状態へのリセット機能

## 状態管理

### ローカル状態

- React Hooks を活用（useState, useReducer）
- 状態の範囲を最小限に保つ
- 関連する状態は useReducer でまとめる

### グローバル状態

- Context API や Zustand を活用
- 状態の更新ロジックを明確に分離
- 適切なメモ化でパフォーマンスを最適化

### サーバー状態

- サーバーコンポーネントを活用したデータフェッチング
- クライアントコンポーネントでは SWR または React Query を検討
- エラー状態とローディング状態の適切な処理

## レスポンシブデザイン

- モバイルファーストアプローチ
- Tailwind の修飾子（sm:, md:, lg:, xl:）を活用
- flexbox と grid レイアウトを適切に使用
- メディアクエリは極力避け、Tailwind の修飾子で対応
- タッチインターフェースの最適化（タップ領域の確保、スワイプジェスチャーの対応など）

## パフォーマンス最適化

### レンダリング最適化

- 不要な再レンダリングを避ける（memo, useCallback, useMemo）
- 大きなリストには仮想化を検討
- Code Splitting と Lazy Loading を活用

### 画像最適化

- Next.js Image コンポーネントを使用
- 適切なサイズとフォーマットを指定
- loading="lazy"属性の活用

### バンドルサイズ最適化

- トリーシェイキングが効くように注意
- 重いライブラリは必要な部分だけをインポート
- 非同期インポートと遅延読み込みを検討

## ベストプラクティス

### コンポーネント設計

- 単一責任の原則に従う
- Props drilling を避ける（Context API などを活用）
- コンポーネントは小さく、再利用可能に

### テスト

- React Testing Library を使用したコンポーネントテスト
- アクセシビリティのテスト
- ユーザーインタラクションのテスト
- スナップショットテスト

### ドキュメンテーション

- コンポーネントの使用例を提供
- Props と API の明確な説明
- Storybook 等でのビジュアルドキュメント作成（必要に応じて）
